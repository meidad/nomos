import chalk from "chalk";
import { loadUserProfile, loadAgentIdentity } from "../config/profile.ts";
import { getConfigValue, setConfigValue, listConfig } from "../db/config.ts";
import { deleteLastTranscriptMessages } from "../db/transcripts.ts";
import { getSession, updateSessionModel } from "../db/sessions.ts";
import { loadMcpConfig } from "../cli/mcp-config.ts";
import { loadSkills } from "../skills/loader.ts";
import { loadAgentConfigs, getActiveAgent } from "../config/agents.ts";
import type { NomosConfig } from "../config/env.ts";
import type { McpServerConfig } from "../sdk/session.ts";

/** Static registry of slash commands for autocomplete and dispatch. */
export const SLASH_COMMANDS = [
  { name: "help", desc: "Show available commands" },
  { name: "clear", desc: "Clear conversation context" },
  { name: "compact", desc: "Compact conversation" },
  { name: "model", desc: "Show/switch model" },
  { name: "thinking", desc: "Set thinking level" },
  { name: "sandbox", desc: "Toggle sandbox mode" },
  { name: "status", desc: "System status overview" },
  { name: "context", desc: "Context usage estimate" },
  { name: "cost", desc: "Session token usage" },
  { name: "history", desc: "Conversation summary" },
  { name: "undo", desc: "Remove last exchange" },
  { name: "profile", desc: "View/edit user profile" },
  { name: "identity", desc: "View/edit agent identity" },
  { name: "skills", desc: "List loaded skills" },
  { name: "agent", desc: "List/switch agent configs" },
  { name: "config", desc: "List runtime settings" },
  { name: "tools", desc: "List available tools" },
  { name: "mcp", desc: "List MCP servers" },
  { name: "memory", desc: "Search/add to memory" },
  { name: "session", desc: "Show session info" },
  { name: "drafts", desc: "List pending draft responses" },
  { name: "approve", desc: "Approve a draft response" },
  { name: "reject", desc: "Reject a draft response" },
  { name: "slack", desc: "List connected Slack workspaces" },
  { name: "quit", desc: "Exit nomos" },
] as const;

/** Mutable runtime state that commands can read/modify. */
export interface CommandState {
  model: string;
  thinkingLevel?: "off" | "minimal" | "low" | "medium" | "high" | "max";
  sandboxEnabled?: boolean;
  activeAgentId?: string;
}

/** Context passed to every slash command handler. */
export interface CommandContext {
  transcript: Array<{ role: string; content: string }>;
  session: { id: string; session_key: string };
  state: CommandState;
  config: NomosConfig;
  mcpServers: Record<string, McpServerConfig>;
}

export interface CommandResult {
  output: string;
  quit?: boolean;
  /** Signal to compact the conversation */
  compact?: boolean;
}

/** Detect if using Vertex AI (@ separator) vs Anthropic API (- separator for date suffix) */
function isVertexAi(): boolean {
  return (
    process.env.CLAUDE_CODE_USE_VERTEX === "1" ||
    Boolean(process.env.GOOGLE_CLOUD_PROJECT && !process.env.ANTHROPIC_API_KEY)
  );
}

/** Available models for /model picker — format varies by provider */
function getAvailableModels(): Array<{ id: string; label: string; desc: string }> {
  const vertex = isVertexAi();
  return [
    { id: "claude-opus-4-6", label: "Opus 4", desc: "most capable" },
    { id: "claude-sonnet-4-6", label: "Sonnet 4", desc: "fast, balanced" },
    {
      id: vertex ? "claude-haiku-4-5@20251001" : "claude-haiku-4-5-20251001",
      label: "Haiku 4",
      desc: "fastest, cheapest",
    },
  ];
}

/**
 * Dispatch a slash command and return the output as a string.
 */
export async function dispatchSlashCommand(
  input: string,
  ctx: CommandContext,
): Promise<CommandResult> {
  const [cmd, ...args] = input.slice(1).split(/\s+/);

  if (!cmd) {
    return { output: cmdHelp() };
  }

  switch (cmd) {
    case "quit":
    case "exit":
    case "q":
      return { output: "", quit: true };
    case "help":
      return { output: cmdHelp() };
    case "clear":
      return { output: cmdClear(ctx) };
    case "model":
      return { output: await cmdModel(ctx, args) };
    case "thinking":
    case "think-hard":
    case "ultrathink":
      return { output: cmdThinking(ctx, args, cmd) };
    case "sandbox":
      return { output: cmdSandbox(ctx, args) };
    case "session":
      return { output: await cmdSession(ctx) };
    case "memory":
      return { output: await cmdMemory(ctx, args) };
    case "config":
      return { output: await cmdConfig(args) };
    case "tools":
      return { output: cmdTools(ctx) };
    case "cost":
      return { output: await cmdCost(ctx) };
    case "history":
      return { output: cmdHistory(ctx) };
    case "undo":
      return { output: await cmdUndo(ctx) };
    case "mcp":
      return { output: await cmdMcp(ctx) };
    case "profile":
      return { output: await cmdProfile(args) };
    case "identity":
      return { output: await cmdIdentity(args) };
    case "skills":
      return { output: await cmdSkills(args) };
    case "compact":
      return cmdCompact(ctx);
    case "status":
      return { output: await cmdStatus(ctx) };
    case "context":
      return { output: cmdContext(ctx) };
    case "agent":
      return { output: await cmdAgent(ctx, args) };
    case "drafts":
      return { output: await cmdDrafts() };
    case "approve":
      return { output: await cmdApproveDraft(args) };
    case "reject":
      return { output: await cmdRejectDraft(args) };
    case "slack":
      return { output: await cmdSlackWorkspaces() };
    case "undo-files":
      return { output: cmdUndoFiles() };
    default:
      return {
        output: chalk.yellow(`Unknown command: /${cmd}. Type /help for available commands.`),
      };
  }
}

// ---------------------------------------------------------------------------
// Individual command handlers — all return strings
// ---------------------------------------------------------------------------

function cmdHelp(): string {
  const lines = [
    chalk.bold("Session"),
    "  /clear             Clear conversation context",
    "  /compact           Compact conversation to reduce context",
    "  /status            Show system status overview",
    "  /context           Show context usage estimate",
    "  /cost              Show session token usage",
    "  /history           Show conversation summary",
    "  /undo              Remove last exchange",
    "  /undo-files        Revert file changes (placeholder)",
    "",
    chalk.bold("Model"),
    "  /model             Show current model and available options",
    "  /model <name|num>  Switch model by name or number",
    "  /thinking          Show/set thinking level (off/minimal/low/medium/high/max)",
    "  /sandbox           Show/toggle sandbox mode (on/off)",
    "",
    chalk.bold("Profile"),
    "  /profile           View user profile",
    "  /identity          View agent identity",
    "  /skills            List loaded skills",
    "  /agent             List/switch agent configs",
    "",
    chalk.bold("Drafts"),
    "  /drafts            List pending draft responses",
    "  /approve <id>      Approve a draft and send as user",
    "  /reject <id>       Reject a draft response",
    "",
    chalk.bold("Config"),
    "  /config            List runtime settings",
    "  /tools             List available tools",
    "  /mcp               List MCP servers",
    "  /memory            Search or add to memory",
    "",
    chalk.bold("Exit"),
    "  /quit  /exit  /q   Exit nomos",
  ];
  return lines.join("\n");
}

function cmdClear(ctx: CommandContext): string {
  ctx.transcript.length = 0;
  return chalk.dim("Conversation cleared (session preserved in DB)");
}

async function cmdModel(ctx: CommandContext, args: string[]): Promise<string> {
  const input = args[0];

  if (!input) {
    // Show current model + available list
    const lines = [chalk.dim(`Current model: ${ctx.state.model}`), ""];
    for (let i = 0; i < getAvailableModels().length; i++) {
      const m = getAvailableModels()[i];
      const current = m.id === ctx.state.model ? chalk.green(" ← current") : "";
      lines.push(
        `  ${chalk.bold(String(i + 1))}. ${chalk.cyan(m.id)}  ${chalk.dim(m.label)} ${chalk.dim(`(${m.desc})`)}${current}`,
      );
    }
    lines.push("", chalk.dim("Use /model <number> or /model <name> to switch."));
    return lines.join("\n");
  }

  // Try numeric selection first
  const num = parseInt(input, 10);
  if (!isNaN(num) && num >= 1 && num <= getAvailableModels().length) {
    const selected = getAvailableModels()[num - 1];
    ctx.state.model = selected.id;
    await updateSessionModel(ctx.session.id, selected.id);
    return chalk.dim(`Model switched to: ${selected.id} (${selected.label})`);
  }

  // Try fuzzy match on label or id
  const lower = input.toLowerCase();
  const match = getAvailableModels().find(
    (m) => m.id.toLowerCase().includes(lower) || m.label.toLowerCase().includes(lower),
  );
  if (match) {
    ctx.state.model = match.id;
    await updateSessionModel(ctx.session.id, match.id);
    return chalk.dim(`Model switched to: ${match.id} (${match.label})`);
  }

  // Fallback: accept any model string directly
  ctx.state.model = input;
  await updateSessionModel(ctx.session.id, input);
  return chalk.dim(`Model switched to: ${input}`);
}

function cmdThinking(ctx: CommandContext, args: string[], cmd: string): string {
  // Handle aliases
  if (cmd === "think-hard") {
    ctx.state.thinkingLevel = "low";
    return chalk.dim("Thinking level set to: low");
  }
  if (cmd === "ultrathink") {
    ctx.state.thinkingLevel = "high";
    return chalk.dim("Thinking level set to: high");
  }

  const validLevels = ["off", "minimal", "low", "medium", "high", "max"];
  const input = args[0];

  // Show current level if no argument
  if (!input) {
    const current = ctx.state.thinkingLevel ?? "high";
    const lines = [
      chalk.dim(`Current thinking level: ${current}`),
      "",
      chalk.bold("Available levels:"),
      `  ${chalk.cyan("off")}      - No extended thinking`,
      `  ${chalk.cyan("minimal")}  - Minimal thinking (1K tokens)`,
      `  ${chalk.cyan("low")}      - Low thinking (2K tokens)`,
      `  ${chalk.cyan("medium")}   - Medium thinking (5K tokens)`,
      `  ${chalk.cyan("high")}     - High/adaptive thinking (default)`,
      `  ${chalk.cyan("max")}      - Maximum thinking (32K tokens)`,
      "",
      chalk.dim("Aliases: /think-hard (low), /ultrathink (high)"),
      chalk.dim("Use /thinking <level> to change."),
    ];
    return lines.join("\n");
  }

  // Validate and set level
  const level = input.toLowerCase();
  if (!validLevels.includes(level)) {
    return chalk.yellow(`Invalid level: ${input}. Valid: ${validLevels.join(", ")}`);
  }

  ctx.state.thinkingLevel = level as typeof ctx.state.thinkingLevel;
  return chalk.dim(`Thinking level set to: ${level}`);
}

function cmdSandbox(ctx: CommandContext, args: string[]): string {
  const input = args[0];

  // Show current status if no argument
  if (!input) {
    const current = ctx.state.sandboxEnabled ?? false;
    const status = current ? chalk.green("enabled") : chalk.red("disabled");
    const lines = [
      chalk.dim(`Sandbox mode: ${status}`),
      "",
      chalk.dim("Use /sandbox on or /sandbox off to toggle."),
      chalk.dim("When enabled, code execution runs in an isolated sandbox environment."),
    ];
    return lines.join("\n");
  }

  // Toggle sandbox mode
  const normalized = input.toLowerCase();
  if (normalized === "on" || normalized === "enable" || normalized === "enabled") {
    ctx.state.sandboxEnabled = true;
    return chalk.dim("Sandbox mode enabled. Code will run in isolated environment.");
  } else if (normalized === "off" || normalized === "disable" || normalized === "disabled") {
    ctx.state.sandboxEnabled = false;
    return chalk.dim("Sandbox mode disabled. Code runs in standard environment.");
  } else {
    return chalk.yellow(`Invalid option: ${input}. Use 'on' or 'off'.`);
  }
}

async function cmdSession(ctx: CommandContext): Promise<string> {
  const row = await getSession(ctx.session.id);
  const lines = [
    chalk.dim(`Session:  ${ctx.session.session_key}`),
    chalk.dim(`Model:    ${ctx.state.model}`),
    chalk.dim(`Messages: ${ctx.transcript.length} in memory`),
  ];
  if (row?.token_usage) {
    lines.push(
      chalk.dim(`Usage:    ${row.token_usage.input} input / ${row.token_usage.output} output`),
    );
  }
  return lines.join("\n");
}

async function cmdProfile(args: string[]): Promise<string> {
  if (!args[0] || args[0] !== "set") {
    const profile = await loadUserProfile();
    const lines = [
      chalk.bold("User Profile:"),
      chalk.dim(`  Name:         ${profile.name ?? "(not set)"}`),
      chalk.dim(`  Timezone:     ${profile.timezone ?? "(not set)"}`),
      chalk.dim(`  Workspace:    ${profile.workspace ?? "(not set)"}`),
      chalk.dim(`  Instructions: ${profile.instructions ?? "(not set)"}`),
      chalk.dim("\nUse /profile set <key> <value> to update. Restart to apply."),
    ];
    return lines.join("\n");
  }

  const key = args[1];
  const value = args.slice(2).join(" ");
  const validKeys = ["name", "timezone", "workspace", "instructions"];
  if (!key || !validKeys.includes(key)) {
    return chalk.yellow(`Valid keys: ${validKeys.join(", ")}`);
  }
  if (!value) {
    return chalk.yellow(`Usage: /profile set ${key} <value>`);
  }
  await setConfigValue(`user.${key}`, value);
  return chalk.dim(`Set user.${key} = ${value}\nRestart the session to apply.`);
}

async function cmdIdentity(args: string[]): Promise<string> {
  if (!args[0] || args[0] !== "set") {
    const identity = await loadAgentIdentity();
    const lines = [
      chalk.bold("Agent Identity:"),
      chalk.dim(`  Name:  ${identity.name}`),
      chalk.dim(`  Emoji: ${identity.emoji ?? "(none)"}`),
      chalk.dim("\nUse /identity set <key> <value> to update. Restart to apply."),
    ];
    return lines.join("\n");
  }

  const key = args[1];
  const value = args.slice(2).join(" ");
  if (key !== "name" && key !== "emoji") {
    return chalk.yellow("Valid keys: name, emoji");
  }
  if (!value) {
    return chalk.yellow(`Usage: /identity set ${key} <value>`);
  }
  await setConfigValue(`agent.${key}`, value);
  return chalk.dim(`Set agent.${key} = ${value}\nRestart the session to apply.`);
}

async function cmdSkills(args: string[]): Promise<string> {
  const skills = loadSkills();

  if (!args[0]) {
    if (skills.length === 0) {
      return chalk.dim("No skills loaded.\nAdd skills to ~/.nomos/skills/ or ./skills/");
    }
    const lines = [chalk.bold(`Skills (${skills.length}):`)];
    for (const skill of skills) {
      const displayName = skill.emoji ? `${skill.emoji} ${skill.name}` : skill.name;
      lines.push(`  ${chalk.cyan(displayName)} ${chalk.dim(`(${skill.source})`)}`);
      if (skill.description) {
        lines.push(`    ${chalk.dim(skill.description)}`);
      }
    }
    return lines.join("\n");
  }

  if (args[0] === "info") {
    const name = args[1];
    if (!name) {
      return chalk.yellow("Usage: /skills info <name>");
    }
    const skill = skills.find((s) => s.name === name);
    if (!skill) {
      return chalk.yellow(`Skill not found: ${name}`);
    }
    const lines = [
      chalk.bold(skill.name) + chalk.dim(` (${skill.source})`),
      skill.description ? chalk.dim(skill.description) : "",
      chalk.dim(`File: ${skill.filePath}`),
      chalk.dim(`Content: ${skill.content.length} characters`),
    ];

    // Show requirements
    if (skill.requires) {
      if (skill.requires.bins && skill.requires.bins.length > 0) {
        lines.push(chalk.dim(`Requires binaries: ${skill.requires.bins.join(", ")}`));
      }
      if (skill.requires.os && skill.requires.os.length > 0) {
        lines.push(chalk.dim(`Requires OS: ${skill.requires.os.join(", ")}`));
      }
    }

    // Show install instructions
    if (skill.install && skill.install.length > 0) {
      lines.push("");
      lines.push(chalk.bold("Installation:"));
      for (const cmd of skill.install) {
        lines.push(`  ${chalk.dim(cmd)}`);
      }
    }

    lines.push("");
    lines.push(skill.content);

    return lines.filter(Boolean).join("\n");
  }

  return chalk.yellow("Usage: /skills  |  /skills info <name>");
}

async function cmdMemory(ctx: CommandContext, args: string[]): Promise<string> {
  const subCmd = args[0];

  if (!subCmd) {
    return chalk.dim("Usage: /memory search <query>  |  /memory add <file>");
  }

  if (subCmd === "search") {
    const queryText = args.slice(1).join(" ");
    if (!queryText) {
      return chalk.yellow("Usage: /memory search <query>");
    }

    try {
      const { generateEmbedding } = await import("../memory/embeddings.ts");
      const { hybridSearch } = await import("../memory/search.ts");

      const embedding = await generateEmbedding(queryText);
      const results = await hybridSearch(queryText, embedding, 5);

      if (results.length === 0) {
        return chalk.dim("No results found.");
      }

      const lines: string[] = [];
      for (const result of results) {
        lines.push(
          chalk.bold(result.path ?? result.source) +
            chalk.dim(` (score: ${result.score.toFixed(4)})`),
        );
        const preview = result.text.slice(0, 200).replace(/\n/g, " ");
        lines.push(chalk.dim(`  ${preview}${result.text.length > 200 ? "..." : ""}`));
        lines.push("");
      }
      return lines.join("\n");
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return chalk.red(`Memory search failed: ${message}`);
    }
  }

  if (subCmd === "add") {
    const filePath = args[1];
    if (!filePath) {
      return chalk.yellow("Usage: /memory add <file>");
    }

    try {
      const fs = await import("node:fs");
      const path = await import("node:path");
      const crypto = await import("node:crypto");
      const { chunkText } = await import("../memory/chunker.ts");
      const { generateEmbeddings } = await import("../memory/embeddings.ts");
      const { storeMemoryChunk } = await import("../db/memory.ts");

      const resolved = path.resolve(filePath);
      if (!fs.existsSync(resolved)) {
        return chalk.red(`File not found: ${resolved}`);
      }

      const content = fs.readFileSync(resolved, "utf-8");
      const chunks = chunkText(content);
      if (chunks.length === 0) {
        return chalk.dim("No content to index.");
      }

      const texts = chunks.map((c) => c.text);
      const embeddings = await generateEmbeddings(texts);

      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        const hash = crypto.createHash("sha256").update(chunk.text).digest("hex").slice(0, 16);
        const id = `${path.relative(process.cwd(), resolved)}:${chunk.startLine}-${chunk.endLine}`;

        await storeMemoryChunk({
          id,
          source: "inline",
          path: resolved,
          text: chunk.text,
          embedding: embeddings[i],
          startLine: chunk.startLine,
          endLine: chunk.endLine,
          hash,
          model: ctx.config.embeddingModel,
        });
      }

      return chalk.dim(`Added ${chunks.length} chunk(s) from ${path.basename(resolved)}`);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return chalk.red(`Memory add failed: ${message}`);
    }
  }

  return chalk.yellow(`Unknown memory subcommand: ${subCmd}`);
}

async function cmdConfig(args: string[]): Promise<string> {
  const subCmd = args[0];

  if (!subCmd) {
    const entries = await listConfig();
    if (entries.length === 0) {
      return chalk.dim("No config values stored.");
    }
    const lines: string[] = [];
    for (const entry of entries) {
      lines.push(chalk.bold(entry.key) + chalk.dim(` = ${JSON.stringify(entry.value)}`));
    }
    return lines.join("\n");
  }

  if (subCmd === "set") {
    const key = args[1];
    const rawValue = args.slice(2).join(" ");
    if (!key || !rawValue) {
      return chalk.yellow("Usage: /config set <key> <value>");
    }
    let value: unknown;
    try {
      value = JSON.parse(rawValue);
    } catch {
      value = rawValue;
    }
    await setConfigValue(key, value);
    return chalk.dim(`Set ${key} = ${JSON.stringify(value)}`);
  }

  if (subCmd === "get") {
    const key = args[1];
    if (!key) {
      return chalk.yellow("Usage: /config get <key>");
    }
    const value = await getConfigValue(key);
    if (value === null) {
      return chalk.dim(`${key} is not set`);
    }
    return chalk.dim(`${key} = ${JSON.stringify(value)}`);
  }

  return chalk.yellow("Usage: /config  |  /config set <key> <value>  |  /config get <key>");
}

function cmdTools(ctx: CommandContext): string {
  const lines = [
    chalk.bold("Tools:"),
    chalk.dim(
      "  All Claude Code built-in tools (Bash, Read, Write, Edit, Glob, Grep, WebSearch, WebFetch, etc.)",
    ),
  ];

  const mcpNames = Object.keys(ctx.mcpServers);
  if (mcpNames.length > 0) {
    lines.push(chalk.bold(`\nMCP Servers (${mcpNames.length}):`));
    for (const name of mcpNames) {
      const config = ctx.mcpServers[name];
      const type = "type" in config ? config.type : "stdio";
      lines.push(`  ${chalk.cyan(name)} ${chalk.dim(`(${type})`)}`);
    }
  }

  return lines.join("\n");
}

async function cmdCost(ctx: CommandContext): Promise<string> {
  const row = await getSession(ctx.session.id);
  if (!row?.token_usage) {
    return chalk.dim("No usage data recorded yet.");
  }

  const { input, output } = row.token_usage;
  const total = input + output;

  const lines = [
    chalk.bold("Session token usage:"),
    chalk.dim(`  Input:  ${input.toLocaleString()} tokens`),
    chalk.dim(`  Output: ${output.toLocaleString()} tokens`),
    chalk.dim(`  Total:  ${total.toLocaleString()} tokens`),
  ];
  return lines.join("\n");
}

function cmdHistory(ctx: CommandContext): string {
  if (ctx.transcript.length === 0) {
    return chalk.dim("No messages in conversation.");
  }

  const lines = [chalk.bold(`Conversation (${ctx.transcript.length} messages):`)];

  for (let i = 0; i < ctx.transcript.length; i++) {
    const msg = ctx.transcript[i];
    const role = msg.role === "user" ? chalk.green("You") : chalk.blue("Nomos");
    const preview = msg.content.slice(0, 120).replace(/\n/g, " ");
    const truncated = msg.content.length > 120 ? "..." : "";
    lines.push(`  ${chalk.dim(`${i + 1}.`)} ${role}: ${preview}${truncated}`);
  }

  return lines.join("\n");
}

async function cmdUndo(ctx: CommandContext): Promise<string> {
  if (ctx.transcript.length < 2) {
    return chalk.dim("Nothing to undo.");
  }

  const last = ctx.transcript[ctx.transcript.length - 1];
  const secondLast = ctx.transcript[ctx.transcript.length - 2];

  let removeCount = 0;
  if (last.role === "assistant" && secondLast.role === "user") {
    ctx.transcript.pop();
    ctx.transcript.pop();
    removeCount = 2;
  } else if (last.role === "user") {
    ctx.transcript.pop();
    removeCount = 1;
  } else {
    ctx.transcript.pop();
    removeCount = 1;
  }

  await deleteLastTranscriptMessages(ctx.session.id, removeCount);
  return chalk.dim(`Removed last ${removeCount} message(s). ${ctx.transcript.length} remaining.`);
}

async function cmdMcp(ctx: CommandContext): Promise<string> {
  const mcpNames = Object.keys(ctx.mcpServers);
  const lines: string[] = [];

  if (mcpNames.length === 0) {
    lines.push(chalk.dim("No MCP servers configured."));
  } else {
    lines.push(chalk.bold(`MCP servers (${mcpNames.length}):`));
    for (const name of mcpNames) {
      const config = ctx.mcpServers[name];
      const type = "type" in config ? (config.type ?? "stdio") : "stdio";
      lines.push(`  ${chalk.cyan(name)} ${chalk.dim(`(${type})`)}`);
    }
  }

  const mcpConfig = await loadMcpConfig();
  if (mcpConfig) {
    const available = Object.keys(mcpConfig).filter((n) => !mcpNames.includes(n));
    if (available.length > 0) {
      lines.push(chalk.dim(`\nAvailable (not loaded): ${available.join(", ")}`));
    }
  }

  return lines.join("\n");
}

function cmdCompact(ctx: CommandContext): CommandResult {
  const msgCount = ctx.transcript.length;
  ctx.transcript.length = 0;
  return {
    output: chalk.dim(`Compacted ${msgCount} messages. Context cleared for fresh start.`),
    compact: true,
  };
}

async function cmdStatus(ctx: CommandContext): Promise<string> {
  const row = await getSession(ctx.session.id);
  const profile = await loadUserProfile();
  const identity = await loadAgentIdentity();
  const skills = loadSkills();
  const mcpNames = Object.keys(ctx.mcpServers);

  const lines = [
    chalk.bold("Status"),
    `  Model:    ${chalk.cyan(ctx.state.model)}`,
    `  Thinking: ${chalk.cyan(ctx.state.thinkingLevel ?? "high")}`,
    `  Sandbox:  ${ctx.state.sandboxEnabled ? chalk.green("enabled") : chalk.red("disabled")}`,
    `  Session:  ${chalk.dim(ctx.session.session_key)}`,
    `  Messages: ${ctx.transcript.length} in memory`,
  ];

  if (row?.token_usage) {
    const { input, output } = row.token_usage;
    const fmtIn = input >= 1000 ? `${(input / 1000).toFixed(1)}K` : String(input);
    const fmtOut = output >= 1000 ? `${(output / 1000).toFixed(1)}K` : String(output);
    lines.push(`  Usage:    ${fmtIn} in / ${fmtOut} out`);
  }

  lines.push(`  Skills:   ${skills.length} loaded`);
  lines.push(`  MCP:      ${mcpNames.length} server(s)`);

  const profileName = profile.name ?? "(not set)";
  const identityName = identity.name;
  lines.push(`  Profile:  ${profileName}`);
  if (identityName !== "Nomos") {
    lines.push(`  Agent:    ${identityName}${identity.emoji ? ` ${identity.emoji}` : ""}`);
  }

  return lines.join("\n");
}

function cmdContext(ctx: CommandContext): string {
  if (ctx.transcript.length === 0) {
    return chalk.dim("No messages in context.");
  }

  // Rough token estimate: ~4 chars per token for English text
  const totalChars = ctx.transcript.reduce((sum, m) => sum + m.content.length, 0);
  const estimatedTokens = Math.round(totalChars / 4);
  const fmtTokens =
    estimatedTokens >= 1000 ? `${(estimatedTokens / 1000).toFixed(1)}K` : String(estimatedTokens);

  const lines = [
    chalk.bold("Context"),
    `  Messages:     ${ctx.transcript.length}`,
    `  Est. tokens:  ~${fmtTokens} (rough estimate)`,
    chalk.dim("\n  Use /compact to reduce context usage."),
  ];
  return lines.join("\n");
}

async function cmdAgent(ctx: CommandContext, args: string[]): Promise<string> {
  const agents = loadAgentConfigs();
  const subCmd = args[0];

  if (!subCmd || subCmd === "list") {
    const lines = [chalk.bold(`Agents (${agents.length}):`)];
    for (const agent of agents) {
      const current =
        agent.id === (ctx.state.activeAgentId ?? "default") ? chalk.green(" ← active") : "";
      lines.push(`  ${chalk.cyan(agent.id)} ${chalk.dim(agent.name)}${current}`);
      if (agent.model) lines.push(`    ${chalk.dim(`model: ${agent.model}`)}`);
    }
    lines.push("", chalk.dim("Use /agent <id> to switch."));
    return lines.join("\n");
  }

  // Switch agent
  const target = getActiveAgent(agents, subCmd);
  if (target.id === "default" && subCmd !== "default") {
    return chalk.yellow(`Agent not found: ${subCmd}. Use /agent list to see available.`);
  }
  ctx.state.activeAgentId = target.id;
  if (target.model) ctx.state.model = target.model;
  if (target.thinkingLevel)
    ctx.state.thinkingLevel = target.thinkingLevel as CommandState["thinkingLevel"];
  return chalk.dim(`Switched to agent: ${target.name} (${target.id})`);
}

async function cmdSlackWorkspaces(): Promise<string> {
  try {
    const { listWorkspaces } = await import("../db/slack-workspaces.ts");
    const workspaces = await listWorkspaces();

    if (workspaces.length === 0) {
      return chalk.dim('No Slack workspaces connected. Run "nomos slack auth" to connect one.');
    }

    const lines = [chalk.bold(`Connected Slack workspaces (${workspaces.length}):`)];
    for (const ws of workspaces) {
      const date =
        ws.created_at instanceof Date ? ws.created_at.toLocaleDateString() : String(ws.created_at);
      lines.push(`  ${chalk.cyan(ws.team_name)} ${chalk.dim(`(${ws.team_id})`)}`);
      lines.push(`    ${chalk.dim(`User: ${ws.user_id}  Connected: ${date}`)}`);
    }
    return lines.join("\n");
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return chalk.red(`Failed to list workspaces: ${message}`);
  }
}

async function cmdDrafts(): Promise<string> {
  try {
    const { listPendingDrafts } = await import("../db/drafts.ts");
    const drafts = await listPendingDrafts();

    if (drafts.length === 0) {
      return chalk.dim("No pending drafts.");
    }

    const lines = [chalk.bold(`Pending drafts (${drafts.length}):`)];
    for (const draft of drafts) {
      const shortId = draft.id.slice(0, 8);
      const ctx = draft.context as Record<string, unknown>;
      const contextLabel =
        ctx.messageType === "dm"
          ? `DM from ${ctx.senderName ?? "unknown"}`
          : ctx.channelName
            ? `#${ctx.channelName}`
            : draft.channel_id;
      const preview = draft.content.slice(0, 80).replace(/\n/g, " ");
      const age = Math.round((Date.now() - new Date(draft.created_at).getTime()) / 60_000);
      const ageFmt = age < 60 ? `${age}m ago` : `${Math.round(age / 60)}h ago`;

      lines.push(`  ${chalk.cyan(shortId)} ${chalk.dim(`[${contextLabel}]`)} ${chalk.dim(ageFmt)}`);
      lines.push(`    ${preview}${draft.content.length > 80 ? "..." : ""}`);
    }

    lines.push("", chalk.dim("Use /approve <id> or /reject <id>"));
    return lines.join("\n");
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return chalk.red(`Failed to list drafts: ${message}`);
  }
}

async function cmdApproveDraft(args: string[]): Promise<string> {
  const prefix = args[0];
  if (!prefix) {
    return chalk.yellow("Usage: /approve <draft-id>");
  }

  try {
    const { getDraftByPrefix, approveDraft, markDraftSent } = await import("../db/drafts.ts");
    const draft = await getDraftByPrefix(prefix);
    if (!draft) {
      return chalk.yellow(`No pending draft found matching "${prefix}"`);
    }
    if (draft.status !== "pending") {
      return chalk.yellow(`Draft ${draft.id.slice(0, 8)} is already ${draft.status}`);
    }

    // Approve the draft
    const approved = await approveDraft(draft.id);
    if (!approved) {
      return chalk.red("Failed to approve draft (may have been processed already)");
    }

    // Send as user
    try {
      const { getWorkspaceByPlatform } = await import("../db/slack-workspaces.ts");
      const ws = await getWorkspaceByPlatform(draft.platform);
      const userToken = ws?.access_token ?? process.env.SLACK_USER_TOKEN;
      if (!userToken) {
        return chalk.red("No Slack user token found for this workspace");
      }
      const { WebClient } = await import("@slack/web-api");
      const client = new WebClient(userToken);
      await client.chat.postMessage({
        channel: draft.channel_id,
        text: draft.content,
        thread_ts: draft.thread_id ?? undefined,
      });
      await markDraftSent(draft.id);
      return chalk.dim(`Draft ${draft.id.slice(0, 8)} approved and sent`);
    } catch (sendErr) {
      const message = sendErr instanceof Error ? sendErr.message : String(sendErr);
      return chalk.red(`Draft approved but send failed: ${message}`);
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return chalk.red(`Failed to approve draft: ${message}`);
  }
}

async function cmdRejectDraft(args: string[]): Promise<string> {
  const prefix = args[0];
  if (!prefix) {
    return chalk.yellow("Usage: /reject <draft-id>");
  }

  try {
    const { getDraftByPrefix, rejectDraft } = await import("../db/drafts.ts");
    const draft = await getDraftByPrefix(prefix);
    if (!draft) {
      return chalk.yellow(`No pending draft found matching "${prefix}"`);
    }
    if (draft.status !== "pending") {
      return chalk.yellow(`Draft ${draft.id.slice(0, 8)} is already ${draft.status}`);
    }

    const rejected = await rejectDraft(draft.id);
    if (!rejected) {
      return chalk.red("Failed to reject draft (may have been processed already)");
    }

    return chalk.dim(`Draft ${draft.id.slice(0, 8)} rejected`);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return chalk.red(`Failed to reject draft: ${message}`);
  }
}

function cmdUndoFiles(): string {
  return chalk.dim(
    "File undo requires V2 SDK (coming soon). Use git to revert changes.\n  git checkout -- <file>  or  git stash",
  );
}
