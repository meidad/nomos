import React, { useState, useRef, useCallback, useEffect } from "react";
import { Box, Text, Static, useApp, useInput } from "ink";
import type { NomosConfig } from "../../config/env.ts";
import type { AgentIdentity } from "../../config/profile.ts";
import { appendTranscriptMessage } from "../../db/transcripts.ts";
import { updateSessionUsage, updateSessionSdkId } from "../../db/sessions.ts";
import { runSession, type McpServerConfig, type SDKMessage } from "../../sdk/session.ts";
import { dispatchSlashCommand, type CommandContext, type CommandState } from "../slash-commands.ts";
import { shouldBootstrap, getBootstrapPrompt } from "../bootstrap.ts";
import { loadHeartbeatFile, isHeartbeatEmpty } from "../../auto-reply/heartbeat.ts";
import type { GatewayClient, ConnectionState } from "../gateway-client.ts";
import type { AgentEvent } from "../../daemon/types.ts";
import { theme } from "../theme.ts";
import { UserMessage } from "./UserMessage.tsx";
import { NomosMessage } from "./NomosMessage.tsx";
import { ToolBlock } from "./ToolBlock.tsx";
import { ThinkingBlock } from "./ThinkingBlock.tsx";
import { CostLine } from "./CostLine.tsx";
import { SystemMessage } from "./SystemMessage.tsx";
import { StatusBar } from "./StatusBar.tsx";
import { CommandInput } from "./CommandInput.tsx";
import { GradientSpinner } from "./GradientSpinner.tsx";

/** A finalized item displayed in the Static section. */
interface UIItem {
  id: string;
  kind: "user" | "assistant" | "system" | "tool" | "tool-progress" | "thinking" | "cost";
  content: string;
  toolMeta?: {
    name: string;
    elapsed: string;
    status: "success" | "error";
    summary?: string;
  };
}

interface ActiveTool {
  name: string;
  startTime: number;
}

let itemCounter = 0;
function nextId(): string {
  return `item-${++itemCounter}`;
}

export interface AppProps {
  config: NomosConfig;
  mcpServers: Record<string, McpServerConfig>;
  session: { id: string; session_key: string };
  transcript: Array<{ role: string; content: string }>;
  systemPromptAppend: string;
  identity: AgentIdentity;
  /** When provided, the App connects to the daemon instead of calling runSession() directly. */
  gatewayClient?: GatewayClient;
  /** Saved SDK session ID from DB for resuming conversations across restarts. */
  savedSdkSessionId?: string | null;
}

export function App({
  config,
  mcpServers,
  session,
  transcript,
  systemPromptAppend,
  identity,
  gatewayClient,
  savedSdkSessionId,
}: AppProps): React.ReactElement {
  const { exit } = useApp();

  // Daemon connection state
  const [connectionState, setConnectionState] = useState<ConnectionState | null>(
    gatewayClient ? "connecting" : null,
  );

  // All finalized items (rendered once via Static)
  const [items, setItems] = useState<UIItem[]>([]);
  // Streaming text for current assistant response
  const [streamingText, setStreamingText] = useState("");
  // Whether we're waiting for the first token
  const [isThinking, setIsThinking] = useState(false);
  // Whether input is active
  const [isInputActive, setIsInputActive] = useState(true);
  const [inputValue, setInputValue] = useState("");
  // Live thinking/reasoning text (streamed then finalized)
  const [thinkingText, setThinkingText] = useState("");
  // Live tool execution indicator
  const [liveToolName, setLiveToolName] = useState<string | null>(null);
  // Use refs for mutable values accessed inside the async for-await loop
  // (React state is stale inside async generators)
  const activeToolRef = useRef<ActiveTool | null>(null);
  const bufferRef = useRef("");
  const thinkingBufferRef = useRef("");
  const flushTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const transcriptRef = useRef(transcript);
  const stateRef = useRef<CommandState>({ model: config.model });
  const systemPromptAppendRef = useRef(systemPromptAppend);
  const bootstrapChecked = useRef(false);
  // SDK session ID for multi-turn resume (enables auto-compaction).
  // Initialized from DB if resuming an existing session.
  const sdkSessionIdRef = useRef<string | null>(savedSdkSessionId ?? null);
  // Track response message UUID for potential undo
  const lastResponseUuidRef = useRef<string | null>(null);

  const pushItem = useCallback(
    (kind: UIItem["kind"], content: string, toolMeta?: UIItem["toolMeta"]) => {
      setItems((prev) => [...prev, { id: nextId(), kind, content, toolMeta }]);
    },
    [],
  );

  const flushBuffer = useCallback(() => {
    if (bufferRef.current) {
      const text = bufferRef.current;
      bufferRef.current = "";
      setStreamingText((prev) => prev + text);
    }
    if (thinkingBufferRef.current) {
      const text = thinkingBufferRef.current;
      thinkingBufferRef.current = "";
      setThinkingText((prev) => prev + text);
    }
    flushTimerRef.current = null;
  }, []);

  const appendDelta = useCallback(
    (text: string) => {
      bufferRef.current += text;
      if (!flushTimerRef.current) {
        flushTimerRef.current = setTimeout(flushBuffer, 50);
      }
    },
    [flushBuffer],
  );

  // Process an AgentEvent from the daemon WebSocket
  const handleDaemonEvent = useCallback(
    (event: AgentEvent) => {
      switch (event.type) {
        case "stream_event": {
          const sdkMsg = event.event as SDKMessage;
          if (sdkMsg.type === "stream_event") {
            const innerEvent = (
              sdkMsg as {
                event: {
                  type: string;
                  delta?: { type: string; text?: string; thinking?: string };
                  content_block?: { type: string; name?: string };
                };
              }
            ).event;
            if (innerEvent.type === "content_block_delta") {
              const delta = innerEvent.delta as { type: string; text?: string; thinking?: string };
              if (delta?.type === "text_delta" && delta.text) {
                if (thinkingBufferRef.current) flushBuffer();
                setIsThinking(false);
                appendDelta(delta.text);
              } else if (delta?.type === "thinking_delta" && delta.thinking) {
                setIsThinking(false);
                thinkingBufferRef.current += delta.thinking;
                if (!flushTimerRef.current) {
                  flushTimerRef.current = setTimeout(flushBuffer, 50);
                }
              }
            } else if (innerEvent.type === "content_block_start") {
              const block = innerEvent.content_block as { type: string; name?: string };
              if (block?.type === "tool_use" && block.name) {
                if (bufferRef.current || thinkingBufferRef.current) flushBuffer();
                activeToolRef.current = { name: block.name, startTime: Date.now() };
                setLiveToolName(block.name);
              } else if (block?.type === "thinking") {
                setIsThinking(false);
              }
            } else if (innerEvent.type === "content_block_stop") {
              if (thinkingBufferRef.current) flushBuffer();
            }
          }
          break;
        }

        case "tool_use_summary": {
          const tool = activeToolRef.current;
          if (tool) {
            const elapsed = ((Date.now() - tool.startTime) / 1000).toFixed(1) + "s";
            pushItem("tool", `${tool.name} (${elapsed})`, {
              name: tool.name,
              elapsed,
              status: "success",
              summary: event.summary || undefined,
            });
            activeToolRef.current = null;
          }
          setLiveToolName(null);
          break;
        }

        case "result": {
          // Flush and finalize
          if (bufferRef.current || thinkingBufferRef.current) flushBuffer();
          setIsThinking(false);
          setLiveToolName(null);
          activeToolRef.current = null;

          // Update token usage
          const inp = event.usage.input_tokens;
          const out = event.usage.output_tokens;
          if (inp > 0 || out > 0) {
            const total = inp + out;
            const fmt = (n: number) => (n >= 1000 ? `${(n / 1000).toFixed(1)}K` : String(n));
            pushItem("cost", `tokens: ${fmt(inp)} in · ${fmt(out)} out · ${fmt(total)} total`);
          }

          setIsInputActive(true);
          break;
        }

        case "system": {
          if (
            event.subtype !== "init" &&
            event.subtype !== "status" &&
            event.subtype !== "command_ack"
          ) {
            pushItem("system", event.message);
          }
          break;
        }

        case "error": {
          if (bufferRef.current || thinkingBufferRef.current) flushBuffer();
          setIsThinking(false);
          setLiveToolName(null);
          activeToolRef.current = null;
          pushItem("system", `Error: ${event.message}`);
          setIsInputActive(true);
          break;
        }
      }
    },
    [pushItem, appendDelta, flushBuffer],
  );

  // Connect to daemon WebSocket if gatewayClient is provided
  useEffect(() => {
    if (!gatewayClient) return;

    gatewayClient.onConnectionStateChange(setConnectionState);
    const removeListener = gatewayClient.onEvent(handleDaemonEvent);

    gatewayClient.connect().catch((err) => {
      pushItem(
        "system",
        `Failed to connect to daemon: ${err instanceof Error ? err.message : String(err)}`,
      );
    });

    return () => {
      removeListener();
      gatewayClient.disconnect();
    };
  }, [gatewayClient, handleDaemonEvent, pushItem]);

  // Run a user message through the SDK (or daemon)
  const handleUserMessage = useCallback(
    async (input: string) => {
      pushItem("user", input);

      await appendTranscriptMessage({
        sessionId: session.id,
        role: "user",
        content: input,
      });
      transcriptRef.current.push({ role: "user", content: input });

      // Reset turn state
      setStreamingText("");
      setThinkingText("");
      setIsThinking(true);
      setIsInputActive(false);
      setLiveToolName(null);
      activeToolRef.current = null;
      thinkingBufferRef.current = "";

      // Daemon mode: send via WebSocket and return
      if (gatewayClient) {
        try {
          gatewayClient.sendMessage(input, session.session_key);
        } catch (err) {
          setIsThinking(false);
          const message = err instanceof Error ? err.message : String(err);
          pushItem("system", `Error: ${message}`);
          setIsInputActive(true);
        }
        return;
      }

      try {
        // Map thinking level to SDK options
        const thinkingLevel = stateRef.current.thinkingLevel ?? "high";
        let thinking:
          | { type: "adaptive" }
          | { type: "enabled"; budgetTokens: number }
          | { type: "disabled" }
          | undefined;

        switch (thinkingLevel) {
          case "off":
            thinking = { type: "disabled" };
            break;
          case "minimal":
            thinking = { type: "enabled", budgetTokens: 1024 };
            break;
          case "low":
            thinking = { type: "enabled", budgetTokens: 2048 };
            break;
          case "medium":
            thinking = { type: "enabled", budgetTokens: 5000 };
            break;
          case "high":
            thinking = { type: "adaptive" };
            break;
          case "max":
            thinking = { type: "enabled", budgetTokens: 32000 };
            break;
        }

        // Auto-approve all tools from our MCP servers so the agent
        // can use them without permission prompts in acceptEdits mode.
        const allowedTools = Object.keys(mcpServers).map((name) => `mcp__${name}`);

        let sdkQuery = runSession({
          prompt: input,
          model: stateRef.current.model,
          mcpServers,
          systemPromptAppend: systemPromptAppendRef.current,
          permissionMode: config.permissionMode,
          resume: sdkSessionIdRef.current ?? undefined,
          thinking,
          allowedTools,
        });

        const textParts: string[] = [];

        // Wrap iteration with resume-fallback: if resuming fails, retry without resume
        const iterate = async function* () {
          try {
            for await (const msg of sdkQuery) {
              yield msg;
            }
          } catch (err) {
            const errMsg = err instanceof Error ? err.message : String(err);
            if (sdkSessionIdRef.current && /session|conversation/i.test(errMsg)) {
              // Resume failed — clear stale session and retry fresh
              sdkSessionIdRef.current = null;
              sdkQuery = runSession({
                prompt: input,
                model: stateRef.current.model,
                mcpServers,
                systemPromptAppend: systemPromptAppendRef.current,
                permissionMode: config.permissionMode,
                thinking,
                allowedTools,
              });
              for await (const msg of sdkQuery) {
                yield msg;
              }
            } else {
              throw err;
            }
          }
        };

        for await (const msg of iterate()) {
          switch (msg.type) {
            case "assistant": {
              // Track response message UUID for potential undo
              const responseMsg = msg as {
                uuid?: string;
                message: { content: Array<{ type: string; text?: string }> };
              };
              if (responseMsg.uuid) {
                lastResponseUuidRef.current = responseMsg.uuid;
              }
              for (const block of msg.message.content) {
                if (block.type === "text" && block.text) {
                  textParts.push(block.text);
                }
              }
              break;
            }

            case "stream_event": {
              const event = msg.event;
              if (event.type === "content_block_delta") {
                const delta = event.delta as { type: string; text?: string; thinking?: string };
                if (delta.type === "text_delta" && delta.text) {
                  // Finalize thinking block if transitioning from thinking to text
                  if (thinkingBufferRef.current) flushBuffer();
                  setIsThinking(false);
                  appendDelta(delta.text);
                } else if (delta.type === "thinking_delta" && delta.thinking) {
                  // Buffer thinking content
                  setIsThinking(false);
                  thinkingBufferRef.current += delta.thinking;
                  if (!flushTimerRef.current) {
                    flushTimerRef.current = setTimeout(flushBuffer, 50);
                  }
                }
              } else if (event.type === "content_block_start") {
                const block = event.content_block as { type: string; name?: string };
                if (block.type === "tool_use" && block.name) {
                  // Flush any buffered text before tool
                  if (bufferRef.current || thinkingBufferRef.current) flushBuffer();
                  // Finalize thinking if we had any
                  if (thinkingText || thinkingBufferRef.current) {
                    // Will be finalized in the effect
                  }
                  activeToolRef.current = { name: block.name, startTime: Date.now() };
                  setLiveToolName(block.name);
                } else if (block.type === "thinking") {
                  setIsThinking(false);
                }
              } else if (event.type === "content_block_stop") {
                // When a thinking block ends, finalize it
                if (thinkingBufferRef.current) flushBuffer();
              }
              break;
            }

            case "tool_use_summary": {
              const tool = activeToolRef.current;
              if (tool) {
                const elapsed = ((Date.now() - tool.startTime) / 1000).toFixed(1) + "s";
                const summary = msg.summary ? ` ${msg.summary}` : undefined;
                pushItem("tool", `${tool.name} (${elapsed})${summary ?? ""}`, {
                  name: tool.name,
                  elapsed,
                  status: "success",
                  summary: msg.summary || undefined,
                });
                activeToolRef.current = null;
              } else if (msg.summary) {
                pushItem("tool", msg.summary);
              }
              setLiveToolName(null);
              break;
            }

            case "tool_progress": {
              const progressMsg = msg as { tool_name: string; elapsed_time_seconds: number };
              setLiveToolName(progressMsg.tool_name);
              break;
            }

            case "system": {
              // Capture SDK session ID for multi-turn resume
              const sysMsg = msg as {
                session_id?: string;
                subtype: string;
                tools?: unknown[];
                mcp_servers?: unknown[];
                status?: string;
                compact_metadata?: { trigger: string; pre_tokens: number };
              };
              if (sysMsg.session_id && !sdkSessionIdRef.current) {
                sdkSessionIdRef.current = sysMsg.session_id;
              }
              if (sysMsg.subtype === "init") {
                const toolCount = (sysMsg.tools as unknown[])?.length ?? 0;
                const mcpCount = (sysMsg.mcp_servers as unknown[])?.length ?? 0;
                pushItem("system", `${toolCount} tools, ${mcpCount} MCP servers`);
              } else if (sysMsg.subtype === "status" && sysMsg.status === "compacting") {
                pushItem("system", "Compacting conversation...");
              } else if (sysMsg.subtype === "compact_boundary" && sysMsg.compact_metadata) {
                const preTokens = sysMsg.compact_metadata.pre_tokens;
                const tokensFormatted =
                  preTokens >= 1000 ? `${(preTokens / 1000).toFixed(1)}K` : String(preTokens);
                pushItem("system", `Context compacted (was ~${tokensFormatted} tokens)`);
              } else if (sysMsg.subtype === "task_started") {
                const taskMsg = sysMsg as unknown as { description: string };
                if (taskMsg.description) {
                  pushItem("system", `Task started: ${taskMsg.description}`);
                }
              } else if (sysMsg.subtype === "task_notification") {
                const taskMsg = sysMsg as unknown as { status: string; summary: string };
                pushItem("system", `Task ${taskMsg.status}: ${taskMsg.summary}`);
              }
              break;
            }

            case "result": {
              if (msg.subtype !== "success") {
                const errorMsg = msg as { errors?: string[] };
                if (errorMsg.errors?.length) {
                  pushItem("system", `Error: ${errorMsg.errors.join(", ")}`);
                }
              }
              // Update token usage
              const inp = msg.usage.input_tokens;
              const out = msg.usage.output_tokens;
              if (inp > 0 || out > 0) {
                const total = inp + out;
                const fmt = (n: number) => (n >= 1000 ? `${(n / 1000).toFixed(1)}K` : String(n));
                pushItem("cost", `tokens: ${fmt(inp)} in · ${fmt(out)} out · ${fmt(total)} total`);
              }

              // Update session usage
              if (inp > 0 || out > 0) {
                updateSessionUsage(session.id, inp, out).catch(() => {});
              }

              // Persist SDK session ID to DB for resume across restarts
              if (sdkSessionIdRef.current) {
                updateSessionSdkId(session.session_key, sdkSessionIdRef.current).catch(() => {});
              }
              break;
            }

            default:
              break;
          }
        }

        // Flush remaining text and thinking
        if (bufferRef.current || thinkingBufferRef.current) flushBuffer();

        setIsThinking(false);
        setLiveToolName(null);
        activeToolRef.current = null;

        // Persist assistant response
        if (textParts.length > 0) {
          const responseText = textParts.join("");
          await appendTranscriptMessage({
            sessionId: session.id,
            role: "assistant",
            content: responseText,
          });
          transcriptRef.current.push({ role: "assistant", content: responseText });
        }
      } catch (error) {
        setIsThinking(false);
        setLiveToolName(null);
        activeToolRef.current = null;
        const message = error instanceof Error ? error.message : String(error);
        pushItem("system", `Error: ${message}`);
      }

      setIsInputActive(true);
    },
    [mcpServers, session.id, pushItem, appendDelta, flushBuffer],
  );

  // When streaming finishes and input becomes active, finalize messages
  useEffect(() => {
    if (isInputActive) {
      if (thinkingText) {
        pushItem("thinking", thinkingText);
        setThinkingText("");
      }
      if (streamingText && streamingText.trim().length >= 3) {
        pushItem("assistant", streamingText);
        setStreamingText("");
      } else if (streamingText) {
        // Silent reply - skip pushing assistant item
        setStreamingText("");
      }
    }
  }, [isInputActive, streamingText, thinkingText, pushItem]);

  // Inject prior conversation context into the system prompt so the agent
  // remembers the user's name, preferences, and recent exchanges.
  // This acts as a safety net even when SDK session resume is available —
  // if the resume works, the SDK already has full context and this is redundant;
  // if the resume fails (expired session), this prevents a cold start.
  useEffect(() => {
    if (bootstrapChecked.current) return;

    if (transcript.length > 0) {
      // Take the most recent messages (limit to avoid huge prompts)
      const recent = transcript.slice(-30);
      const history = recent.map((m) => `[${m.role}]: ${m.content.slice(0, 500)}`).join("\n\n");
      systemPromptAppendRef.current =
        systemPromptAppendRef.current +
        "\n\n## Previous Conversation\n" +
        "The following is the most recent conversation history with this user. " +
        "Use it to maintain continuity — remember their name, preferences, and context. " +
        "Do NOT re-introduce yourself or ask who they are if you can see prior exchanges.\n\n" +
        history;
    }
  }, [transcript]);

  // Check for first-run bootstrapping
  useEffect(() => {
    if (bootstrapChecked.current) return;
    bootstrapChecked.current = true;

    (async () => {
      const needsBootstrap = await shouldBootstrap(transcript.length);
      if (!needsBootstrap) return;

      // Inject bootstrap prompt into system prompt
      const bootstrapPrompt = getBootstrapPrompt(identity);
      systemPromptAppendRef.current = systemPromptAppend + "\n\n" + bootstrapPrompt;

      // Auto-send a greeting to trigger the bootstrap conversation
      await handleUserMessage("Hello!");
    })();
  }, [identity, systemPromptAppend, handleUserMessage, transcript.length]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (flushTimerRef.current) {
        clearTimeout(flushTimerRef.current);
      }
    };
  }, []);

  // Heartbeat system: periodically check HEARTBEAT.md and send as user message if non-empty
  useEffect(() => {
    if (config.heartbeatIntervalMs <= 0) return;

    const intervalId = setInterval(() => {
      // Only send heartbeat when input is active (agent is idle)
      if (!isInputActive) return;

      const heartbeatContent = loadHeartbeatFile();
      if (!heartbeatContent || isHeartbeatEmpty(heartbeatContent)) return;

      // Send heartbeat content as a user message with a system note
      const heartbeatMessage = `${heartbeatContent}\n\n<!-- Heartbeat check — review HEARTBEAT.md for pending tasks -->`;
      handleUserMessage(heartbeatMessage);
    }, config.heartbeatIntervalMs);

    return () => clearInterval(intervalId);
  }, [config.heartbeatIntervalMs, isInputActive, handleUserMessage]);

  // Handle input submission
  const handleSubmit = useCallback(
    async (value: string) => {
      const input = value.trim();
      setInputValue("");
      if (!input) return;

      if (input.startsWith("/")) {
        const ctx: CommandContext = {
          transcript: transcriptRef.current,
          session,
          state: stateRef.current,
          config,
          mcpServers,
        };

        const result = await dispatchSlashCommand(input, ctx);

        if (result.quit) {
          exit();
          return;
        }

        if (result.output) {
          pushItem("system", result.output);
        }

        if (result.compact) {
          // Clear items visually and reset SDK session (fresh context)
          setItems([]);
          sdkSessionIdRef.current = null;
        }
        return;
      }

      await handleUserMessage(input);
    },
    [session, config, mcpServers, handleUserMessage, pushItem, exit],
  );

  useInput((_input, key) => {
    if (key.ctrl && _input === "c") {
      exit();
    }
  });

  const promptChar = identity.emoji ? `${identity.emoji} ` : "";

  return (
    <Box flexDirection="column">
      {/* Completed items — rendered once, scroll up */}
      <Static items={items}>
        {(item) => {
          switch (item.kind) {
            case "user":
              return <UserMessage key={item.id} content={item.content} />;
            case "assistant":
              return <NomosMessage key={item.id} content={item.content} />;
            case "thinking":
              return <ThinkingBlock key={item.id} content={item.content} />;
            case "tool":
              return item.toolMeta ? (
                <ToolBlock key={item.id} {...item.toolMeta} />
              ) : (
                <SystemMessage key={item.id} content={item.content} />
              );
            case "tool-progress":
              return <SystemMessage key={item.id} content={item.content} />;
            case "cost":
              return <CostLine key={item.id} content={item.content} />;
            case "system":
              return <SystemMessage key={item.id} content={item.content} />;
            default:
              return null;
          }
        }}
      </Static>

      {/* Thinking indicator with gradient spinner */}
      {isThinking && !streamingText && !thinkingText && (
        <Box marginTop={1}>
          <GradientSpinner label="Thinking..." />
        </Box>
      )}

      {/* Live thinking/reasoning — single-line preview to avoid Ink redraw issues */}
      {thinkingText && !isInputActive && (
        <Box marginTop={0}>
          <GradientSpinner
            label={`Reasoning... ${thinkingText.replace(/\n/g, " ").trim().slice(-60)}`}
          />
        </Box>
      )}

      {/* Live tool execution indicator */}
      {liveToolName && !isInputActive && <ToolBlock name={liveToolName} status="executing" />}

      {/* Streaming text */}
      {streamingText && <NomosMessage content={streamingText} />}

      {/* Input area */}
      {isInputActive && (
        <Box marginTop={1}>
          <CommandInput
            value={inputValue}
            onChange={setInputValue}
            onSubmit={handleSubmit}
            focus={isInputActive}
            prompt={`${promptChar}${theme.symbol.user} `}
          />
        </Box>
      )}

      {/* Connection status (daemon mode) */}
      {connectionState && connectionState !== "connected" && (
        <Box>
          <Text color="yellow" dimColor>
            {connectionState === "connecting"
              ? "Connecting to daemon..."
              : connectionState === "reconnecting"
                ? "Reconnecting to daemon..."
                : "Disconnected from daemon"}
          </Text>
        </Box>
      )}

      {/* Status bar */}
      {isInputActive && (
        <StatusBar model={stateRef.current.model} messageCount={transcriptRef.current.length} />
      )}
    </Box>
  );
}
